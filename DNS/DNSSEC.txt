Lets take an example of "verisigninc.com".

We first validate the root servers. How do we do verify the root server is not tampered? We know, In the Root Signing Ceremony, several selected individuals from around the world come together and sign the root DNSKEY RRset in a very public and highly audited way. So we have hardcoded the signed DS records for root in our code which is obtained from http://data.iana.org/root-anchors/root-anchors.xml. As we can see, the <DigestType> in the xml is 2 which means it is sha256, so we generate our hash at root level using sha256 and compare the generated hash with the hardcoded DS values. After the root server is verified and we got next level servers for "com.",  we go down the domain hierarchy. Next we query verisigninc.com. to the IPs we got from Top Level Domain Servers(TLDs). Once we get a result(RRset) from the DNS server, we again need to verify the result. So first we ask for the signature(RRsig), and the public key(KSK) corresponding with the private key which was used to sign the NS records(RRset). We can verify that the record is valid by using python API (dns.dnssec.validate) which takes RRset, RRsig, domain and it throws an exception if validation fails. But this step is not enough. It may happen that DNSKEY(KSK) and RRsig values were modified by some compromised parent DNS server. In that case, we need to build a chain of trust within a zone and connect it to its parent zone. We do this by comparing DS record given by the parent zone and hash generated by the child zone. This DS record is not in the "verisigninc.com" zone. It’s in the “com” zone. So how does your resolver know that this DS record hasn’t been modified? Because “com” also has a DNSKEY record, and has signed the DS record using its private key, placing the result in another "RRSIG" record. How do we know that the DNSKEY record for "com" is valid? Because the root zone has a DS record containing a fingerprint of it, and a DNSKEY record, and an RRSIG record to go along with it. This way we create a chain of trust between root zones and all lower level zones. 

So to identify "DNSSEC failed", we use a two step validation : 1) just check if parent's DS record matches with the child's generated hash using its DNSKEY(KSK). 2) validate the signature(RRsig) and record(RRset) of the child. 

To verify the case for “DNSSEC	not	supported”, if at any zone, if it cannot give signature(RRsig) or its public key(KSK) or its child zone's DS, we say that the DNSSEC is not supported by that domain. It may also throw an exception when we query for DNSKEY.